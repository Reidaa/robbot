name: Deploy
'on':
  workflow_dispatch:
    inputs:
      environment:
        description: Select environment
        required: true
      choice:
        description: Choice of environment
        type: choice
        options: [ 'production', 'staging' ]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: '${{ github.repository }}'
  APP_NAME: robbot
  CONTAINER: docker
jobs:
  publish:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
      - name: Setup Docker buildx
        uses: docker/setup-buildx-action@v2
      - name: 'Log into registry ${{ env.REGISTRY }}'
        uses: docker/login-action@v2
        with:
          registry: '${{ env.REGISTRY }}'
          username: '${{ github.actor }}'
          password: '${{ secrets.GITHUB_TOKEN }}'
      - name: Extract Docker metadata
        id: meta
        uses: docker/metadata-action@v4
        with:
          images: '${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}'
      - name: Build and Push
        uses: docker/build-push-action@v4
        with:
          context: .
          push: '${{ github.event_name != ''pull_request'' }}'
          tags: '${{ steps.meta.outputs.tags }}'
          labels: '${{ steps.meta.outputs.labels }}'
          cache-from: type=gha
          cache-to: 'type=gha,mode=max'
  deploy:
    needs: publish
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment }}
    steps:
      - name: Extract Docker metadata
        id: meta
        uses: docker/metadata-action@v4
        with:
          images: '${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}'
      - name: Initialize the ssh-agent
        uses: webfactory/ssh-agent@v0.4.1
        with:
          ssh-private-key: '${{ secrets.SSH_PRIVATE_KEY }}'
      - name: Scan the host key
        run: |
          mkdir -p ~/.ssh/
          ssh-keyscan -H $SSH_HOST >> ~/.ssh/known_hosts
        env:
          SSH_HOST: '${{ secrets.SSH_HOST }}'
      - name: SSH into the server and pull the image and run it
        run: |
          ssh $SSH_USER@$SSH_HOST "$CONTAINER pull $IMAGE_TAG"
          ssh $SSH_USER@$SSH_HOST "$CONTAINER container stop $APP_NAME || true"
          ssh $SSH_USER@$SSH_HOST "$CONTAINER container rm -f $APP_NAME || true"
          ssh $SSH_USER@$SSH_HOST "$CONTAINER run -e DB_PROVIDER=$DB_PROVIDER -e POSTGRES_USER=$POSTGRES_USER -e POSTGRES_PASSWORD=$POSTGRES_PASSWORD -e POSTGRES_DB=$POSTGRES_DB -e POSTGRES_HOST=$POSTGRES_HOST -e REDDIT_ID=$REDDIT_ID -e REDDIT_SECRET=$REDDIT_SECRET -e REDDIT_AGENT=$REDDIT_AGENT -e DISCORD_TOKEN=$DISCORD_TOKEN --name $APP_NAME -d --restart unless-stopped $IMAGE_TAG"
        env:
          IMAGE_TAG: '${{ steps.meta.outputs.tags }}'
          APP_NAME: '${{ env.APP_NAME }}'
          SSH_USER: '${{ secrets.SSH_USER }}'
          SSH_HOST: '${{ secrets.SSH_HOST }}'
          DB_PROVIDER: '${{ vars.DB_PROVIDER }}'
          POSTGRES_USER: '${{ secrets.POSTGRES_USER }}'
          POSTGRES_PASSWORD: '${{ secrets.POSTGRES_PASSWORD }}'
          POSTGRES_DB: '${{ secrets.POSTGRES_DB }}'
          POSTGRES_HOST: '${{ secrets.POSTGRES_HOST }}'
          REDDIT_ID: '${{ secrets.REDDIT_ID }}'
          REDDIT_SECRET: '${{ secrets.REDDIT_SECRET }}'
          REDDIT_AGENT: '${{ vars.REDDIT_AGENT }}'
          DISCORD_TOKEN: '${{ secrets.DISCORD_TOKEN }}'
